name: Deploy Microservices

on:
  push:
    branches: [main, dev, staging]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'main'

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Get branch name
        id: branch
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            echo "name=${{ github.event.inputs.branch }}" >> $GITHUB_OUTPUT
          else
            echo "name=${GITHUB_REF#refs/heads/}" >> $GITHUB_OUTPUT
          fi

      - name: Deploy to VPS
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_SSH_KEY }}
          port: ${{ secrets.SERVER_SSH_PORT }}
          command_timeout: 30m
          script: |
            set -e

            BRANCH="${{ steps.branch.outputs.name }}"
            DEPLOY_DIR="${{ secrets.SERVER_DEPLOY_DIR }}"

            echo "üöÄ Deploying branch: $BRANCH to $DEPLOY_DIR"

            # Create deploy directory if not exists
            mkdir -p "$DEPLOY_DIR"
            cd "$DEPLOY_DIR"

            # Pull latest code
            echo "üì• Pulling latest code..."
            if [ -d .git ]; then
              git fetch origin "$BRANCH"
              git reset --hard "origin/$BRANCH"
            else
              git clone -b "$BRANCH" "https://${{ secrets.PAT_TOKEN }}@github.com/${{ github.repository }}.git" .
            fi

            # Copy production docker-compose from deploy directory to root
            # This allows build context '.' to work correctly from root
            echo "üìã Configuring docker-compose..."
            cp deploy/docker-compose.yml docker-compose.yml

            # Also copy the multi-stage Dockerfile to root as Dockerfile.production if needed
            # But the docker-compose points to 'Dockerfile' (NestJS default)
            # We need to overwrite the default Dockerfile with our multi-stage one for production builds
            # OR better, point docker-compose to deploy/Dockerfile
            # Let's updating docker-compose to use deploy/Dockerfile in build context
            # BUT: The docker-compose we created uses 'dockerfile: Dockerfile'.
            # We should copy deploy/Dockerfile to Dockerfile.production and use that,
            # Or just overwrite Dockerfile.
            # Decision: Overwrite Dockerfile with deploy/Dockerfile for production build
            cp deploy/Dockerfile Dockerfile

            # Create .env file from secrets - SKIPPED (Managed manually on server)
            # User must create .env file on VPS manually for the first time
            if [ ! -f .env ]; then
              echo "‚ö†Ô∏è .env file not found! Please create it on the server."
            else
              echo "‚úÖ Found existing .env file."
            fi

            # Build images
            echo "üî® Building Docker images..."
            # Using --remove-orphans to clean up old containers
            docker compose build

            # Restart services
            echo "üîÑ Restarting services..."

            # Force compose down first
            echo "üßπ Stopping compose services..."
            docker compose down --remove-orphans --volumes=false --timeout 30 2>/dev/null || true

            # Wait a bit for resources to be released
            sleep 3

            # Force remove ALL examio-be containers (including stuck ones)
            # Uses 'examio-' prefix to NOT affect examio-fe containers
            echo "üßπ Force removing all examio backend containers..."
            docker ps -aq --filter "name=examio-" | grep -v "examio-fe" | xargs -r docker rm -f 2>/dev/null || true

            # Also try by compose project name (examio-be specific)
            docker ps -aq --filter "label=com.docker.compose.project=examio-be" | xargs -r docker rm -f 2>/dev/null || true

            # Remove orphaned networks
            echo "üßπ Cleaning up networks..."
            docker network ls --filter "name=examio" -q | xargs -r docker network rm 2>/dev/null || true

            # Wait for cleanup to complete
            sleep 2

            # Start fresh
            echo "üöÄ Starting services..."
            docker compose up -d --remove-orphans

            # Cleanup only examio-related resources
            echo "üßπ Cleaning up old Examio images..."
            # Remove old examio images (keep current ones in use)
            docker images --filter "reference=*examio*" --filter "dangling=true" -q | xargs -r docker rmi -f 2>/dev/null || true
            # Remove dangling images only (safe, won't affect other projects)
            docker image prune -f
            # Clean build cache for this project only
            docker builder prune -f --filter "until=24h" || true

            # Health Check Verification
            echo "‚è≥ Waiting for services to be healthy..."
            sleep 20

            # Check Gateway Health
            if docker compose exec -T gateway wget -q --spider http://localhost:7000/api/v1/health; then
               echo "‚úÖ Gateway is healthy!"
            else
               echo "‚ùå Gateway health check failed!"
               docker compose logs gateway --tail=50
               # Optional: Rollback logic here
               exit 1
            fi

            echo "üéâ Deployment completed successfully!"

      - name: Deployment Status Notification
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ Deployment successful"
          else
            echo "‚ùå Deployment failed"
            exit 1
          fi
